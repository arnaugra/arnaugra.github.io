Hace unos d√≠as visit√© a un amigo y, cenando, acabamos hablando de trabajo (como siempre), y acabamos leyendo algunos subreddits, encontramos uno donde alguien ped√≠a ayuda para optimizar unos endpoints de una API.

Contaba que pas√≥ a usar [template literals](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) con las variables necesarias para cambiar los valores en la query y las [CASE EXPRESSIONS](https://www.ibm.com/docs/en/informix-servers/12.10.0?topic=expressions-case) para las condiciones en vez de aplicar un mont√≥n de ifs en la aplicaci√≥n para concatenar strings como √©l se encontr√≥. Luego necesitaba modificar algunos valores, as√≠ que recorr√≠a todos los campos y cambiaba solo los necesarios.

Con el c√≥digo que hab√≠a en la publicaci√≥n, pudimos ver claro cu√°les eran sus problemas de rendimiento:
1. **No paginar realmente**, ya que obten√≠a todos los valores (a√∫n teniendo par√°metros en la funci√≥n para ello) y solo al iterar la respuesta obten√≠a los que estaban dentro de su rango deseado. (voy a dejar este concepto a un lado en este caso üòÖ)
2. **Usar programaci√≥n declarativa** para iterar la respuesta.

No est√° mal, existe por una raz√≥n, y suele ser m√°s r√°pido de escribir e incluso m√°s legible. Pero con grandes vol√∫menes de datos, como parec√≠a ser ese caso.

## ¬øQu√© es la programaci√≥n imperativa?
La programaci√≥n imperativa es indicar paso a paso qu√© ha de hacer el c√≥digo. T√∫ **controlas** el proceso y el flujo de ejecuci√≥n depende 100% de tus instrucciones.

Es como seguir una receta. Para obtener un s√°ndwich, has de seguir unos pasos en un orden para obtener un resultado.

```js
const pedidos = [
  ["jam√≥n", "queso"],
  ["lechuga", "huevo"],
  ["tomate", "at√∫n"]
];

const sandwiches = [];

for (let i = 0; i < pedidos.length; i++) {
  const ingredientes = pedidos[i];
  const texto = `S√°ndwich con ${ingredientes.join(" y ")}`;
  sandwiches.push(texto);
}

console.log(sandwiches);
// [
//   "S√°ndwich con jam√≥n y queso",
//   "S√°ndwich con lechuga y huevo",
//   "S√°ndwich con tomate y at√∫n"
// ]
```

De este modo, t√∫ controlas totalmente la ejecuci√≥n, y sabes en todo momento qu√© es lo que hace el c√≥digo y puedes modificarlo a tu gusto.

Puede ser m√°s verboso, o dif√≠cil de mantener a largo plazo, sobre todo en procesos complejos, pero es la mayor aproximaci√≥n a programar con √≥rdenes directas a una m√°quina.

## ¬øQu√© es la programaci√≥n declarativa?
La programaci√≥n declarativa es todo lo contrario. En lugar de decirle al programa **c√≥mo** hacer algo, simplemente le dices **qu√© quieres que haga**, y dejas que se encargue del ‚Äúc√≥mo‚Äù.

Siguiendo con el ejemplo del s√°ndwich, no das instrucciones paso a paso. Simplemente haces un pedido, como si estuvieras en un bar.

```js
const pedidos = [
  ["jam√≥n", "queso"],
  ["lechuga", "huevo"],
  ["tomate", "at√∫n"]
];

const sandwiches = pedidos.map(ingredientes => 
  `S√°ndwich con ${ingredientes.join(" y ")}`
);

console.log(sandwiches);
// [
//   "S√°ndwich con jam√≥n y queso",
//   "S√°ndwich con lechuga y huevo",
//   "S√°ndwich con tomate y at√∫n"
// ]
```

Aqu√≠ no importa tanto el proceso, lo importante es que el resultado cumpla con lo que t√∫ has pedido: **quieres un s√°ndwich** con ciertos ingredientes.

En JavaScript usamos este enfoque todo el tiempo con m√©todos como `.map()`, `.filter()`, `.reduce()`, etc...

## Rendimiento

Al trabajar con pocos datos, para el usuario es imperceptible cu√°l es m√°s r√°pido, pero hablando de eficiencia, el estilo imperativo es claramente superior.

Hay sitios como [perf.link](https://perf.link) en los que podemos comparar la eficiencia en varios trozos de c√≥digo con unos valores globales.

En este ejemplo, creo un array global con 1000 posiciones, y en los dos casos busco el valor 200, en el primer caso con imperativo, y en el segundo con declarativo usando `.find()`.

![Comparaci√≥n rendimiento imperativo vs declarativo](/assets/img/ImperativoVsDeclarativo.webp)

Podemos ver que en el primer caso, realizamos **+2M** de operaciones por segundo, y en el segundo solo **120K**.

Al final, los m√©todos como `.map()`, `.filter()` o `.find()`, son c√≥modos, r√°pidos de usar, y muy eficientes si no esperamos trabajar con grandes cantidades de datos, o para crear un *MVP*. Escribe el c√≥digo pensando en que t√∫ mismo volver√°s a √©l dentro de un mes. Debe ser claro tanto para ti como para cualquier compa√±ero de equipo, y sobre todo, saber cu√°ndo y por qu√© conviene usar cada estilo en cada caso.
